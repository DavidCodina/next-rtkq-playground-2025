import { FetchBaseQueryError } from '@reduxjs/toolkit/query'
import { SerializedError } from '@reduxjs/toolkit'

export function isFetchBaseQueryError(
  error: unknown
): error is FetchBaseQueryError {
  return typeof error === 'object' && error !== null && 'status' in error
}

///////////////////////////////////////////////////////////////////////////
//
// ⚠️ Gotcha: The error returned by query and mutation hook is a footgun.
// When using fetchBaseQuery, the error property returned from a hook will
// have the type:
//
//   FetchBaseQueryError | SerializedError | undefined
//
// https://redux-toolkit.js.org/rtk-query/usage-with-typescript#type-safe-error-handling
// Users should make sure that they are checking which kind of error they are dealing with
// before attempting to access its properties. This can be done in a type safe manner
// either by using a type guard, e.g. by checking for discriminated properties, or using a type predicate.
//
// If the error is coming from our server, it will be a FetchBaseQueryError.
// Assuming that our own server convention is to respond with:
//
//   { code: string; data: null; message: string; success: false; }
//
// The message will be on error.data.message. However, in other variations of
// FetchBaseQueryError, the actual message will be on error.error. Finally,
// in the case of SerializeError, it might just be error.message.
//
///////////////////////////////////////////////////////////////////////////

export const getRTKQueryErrorMessage = (
  error: FetchBaseQueryError | SerializedError | undefined
): string => {
  if (!error || typeof error !== 'object') {
    return ''
  }

  // This generally implies a FetchBaseQueryError, though data
  // can technically be  of type: string | unknown | undefined.
  if ('data' in error && error.data) {
    // This would be coming directly from our server,
    // which uses { code, data, message, success }
    if (
      typeof error.data === 'object' &&
      'message' in error.data &&
      typeof error.data.message === 'string'
    ) {
      return error.data.message
    }
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // This also implies a FetchBaseQueryError, but the error is being generated by RTK Query.
  // In all four cases, there will also be an error.error property, which is a string.
  // However, I've chosen to instead return generic messages rather than expose the actual
  // issue. Why? This function is intended for client UI, not developer debugging. Moreover,
  // the actual raw error.error may be somewhat misleading and inappropriate for UI. For example,
  // in the case of the server simply not being on, I got a PARSING_ERROR where the actual error.error was:
  //
  //   "SyntaxError: Unexpected token 'I', \"Internal S\"... is not valid JSON"
  //
  // Obviously, that's not super helpful.
  //
  ///////////////////////////////////////////////////////////////////////////

  if ('status' in error && typeof error.status === 'string') {
    switch (error.status) {
      case 'FETCH_ERROR':
        return 'A fetch error occurred.'

      case 'PARSING_ERROR':
        return 'A parsing error occurred.'

      case 'TIMEOUT_ERROR':
        return 'A timeout error occurred.'

      case 'CUSTOM_ERROR':
        return 'A custom error occurred.'
    }
  }

  // This implies a SerializedError. However, even then message can be undefined.
  if ('message' in error && typeof error.message === 'string') {
    return error.message
  }

  return 'Internal Server Error.'
}
